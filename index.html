<!DOCTYPE html>
<html>
  <head>
    <title>YieldToBrowser Sandbox</title>
    <meta charset="UTF-8" />
  </head>

  <body>
    <div id="app"><ol id="log"></ol></div>
    <script src="dist/yieldToBrowser.umd.js" type="text/javascript"></script>
    <script>
      /**
       * @returns {Promise<number>}
       */
      function yieldToBrowserAsync() {
        return new Promise(resolve => yieldToBrowser(time => resolve(time)));
      }
    </script>
    <script>
      // main.js

      const list = document.getElementById("log");
      const formatTime = num => num.toFixed(2);
      function appendLog(log) {
        const text = document.createTextNode(log);

        const logItem = document.createElement("li");
        logItem.appendChild(text);

        list.appendChild(logItem);
      }

      async function callback1(time) {
        appendLog("callback1: " + formatTime(time));

        // Queue up a yield from within another yield to validate
        // proper behavior
        time = await yieldToBrowserAsync();
        appendLog("await 1: " + formatTime(time));

        // Verify the Promise form of yield actually does delay until
        // the next frame
        time = await yieldToBrowserAsync();
        appendLog("await 2: " + formatTime(time));
      }

      function callback2(time) {
        appendLog("callback2: " + formatTime(time));
      }

      function callback3(time) {
        appendLog("callback3: " + formatTime(time));
      }

      function main() {
        // Since these yields should be called in the same frame, they
        // should append a log with the same time. The first two are in
        // the same stack and so should be flushed together. The third
        // should run in this frame since it is run when the microTask
        // queue is flushed at the end of this stack.
        yieldToBrowser(callback1);
        yieldToBrowser(callback2);
        Promise.resolve().then(() => yieldToBrowser(callback3));
      }

      main();
    </script>
  </body>
</html>
