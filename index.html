<html>

<head>
    <title>YieldToBrowser Sandbox</title>
    <meta charset="UTF-8" />
</head>

<body>
    <div id="app">
        <ol id="log"></ol>
    </div>
    <script>
        // yieldToBrowser.js

        /** Only schedule animation frame once per frame */
        let isFlushScheduled = false;

        /** Queue of functions to invoke */
        let callbacks = [];

        /** A unique message key to identify our message event apart from others */
        const messageKey =
            "___yieldToBrowser$" +
            Math.random()
                .toString(36)
                .slice(2);

        // Flush the callback queue when a message is posted to the window with
        // our message key
        window.addEventListener("message", event => {
            if (event.source !== window || event.data !== messageKey) {
                return;
            }

            isFlushScheduled = false;
            flushCallbacks();
        });

        function flushCallbacks() {
            // Reset the callback queue to an empty list in case callbacks call
            // yieldToBrowser. These calls to yieldToBrowser should queue up a new
            // callback to be flushed in the next yield and should not impact the
            // current queue being flushed
            let toFlush = callbacks;
            callbacks = [];

            time = performance.now();
            for (let i = 0; i < toFlush.length; i++) {
                // Call all callbacks with the time the flush began, for debug purposes
                toFlush[i](time);
            }

            // Ensure the callback is will be garbage collected
            toFlush = null;
        }

        /**
         * @param {(time: number) => void} callback
         */
        function yieldToBrowser(callback) {
            if (!isFlushScheduled) {
                isFlushScheduled = true;
                requestAnimationFrame(() => {
                    window.postMessage(messageKey, "*");
                });
            }

            callbacks.push(callback);
        }

    </script>
    <script>
        // yieldToBrowserAsync.js

        function yieldToBrowserAsync() {
            return new Promise(resolve => yieldToBrowser(time => resolve(time)));
        }
    </script>
    <script>
        // main.js

        const list = document.getElementById('log');
        function appendLog(log) {
            if (log.toFixed) {
                log = log.toFixed(2);
            }

            const text = document.createTextNode(log);

            const logItem = document.createElement('li');
            logItem.appendChild(text);

            list.appendChild(logItem);
        }

        async function callback1(time) {
            appendLog(time);

            // Queue up a yield from within another yield to validate
            // proper behavior
            time = await yieldToBrowserAsync();
            appendLog(time);

            // Verify the Promise form of yield actually does delay until
            // the next frame
            time = await yieldToBrowserAsync();
            appendLog(time);
        }

        function callback2(time) {
            appendLog(time);
        }

        function callback3(time) {
            appendLog(time);
        }

        function main() {
            // Since these yields should be called in the same frame, they
            // should append a log with the same time. The first two are in
            // the same stack and so should be flushed together. The third
            // should run in this frame since it is run when the microTask
            // queue is flushed at the end of this stack.
            yieldToBrowser(callback1);
            yieldToBrowser(callback2);
            Promise.resolve().then(() => yieldToBrowser(callback3))
        }

        main();
    </script>
</body>

</html>
